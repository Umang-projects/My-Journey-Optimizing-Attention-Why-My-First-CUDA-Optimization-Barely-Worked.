# -*- coding: utf-8 -*-
"""Host_Verification(CPU).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/118tCIkRq8FjFQaanNsR7CwscG9g8AajR
"""

// ==================================================================================
// Host Code (CPU) for Verification and Driving the Application
// ==================================================================================

void attention_on_cpu(const std::vector<float>& q, const std::vector<float>& k, const std::vector<float>& v, std::vector<float>& output) {
    std::vector<float> scores(SEQ_LEN * SEQ_LEN);
    float scale = 1.0f / sqrtf((float)D_K);

    // 1. Q * K^T and Scale
    for (int r = 0; r < SEQ_LEN; ++r) {
        for (int c = 0; c < SEQ_LEN; ++c) {
            float sum = 0.0f;
            for (int i = 0; i < D_K; ++i) {
                sum += q[r * D_K + i] * k[c * D_K + i];
            }
            scores[r * SEQ_LEN + c] = sum * scale;
        }
    }

    // 2. Softmax
    for (int r = 0; r < SEQ_LEN; ++r) {
        float max_val = -1e20f;
        for (int c = 0; c < SEQ_LEN; ++c) {
            max_val = std::max(max_val, scores[r * SEQ_LEN + c]);
        }
        float exp_sum = 0.0f;
        for (int c = 0; c < SEQ_LEN; ++c) {
            scores[r * SEQ_LEN + c] = expf(scores[r * SEQ_LEN + c] - max_val);
            exp_sum += scores[r * SEQ_LEN + c];
        }
        for (int c = 0; c < SEQ_LEN; ++c) {
            scores[r * SEQ_LEN + c] /= exp_sum;
        }
    }

    // 3. Matmul with V
    for (int r = 0; r < SEQ_LEN; ++r) {
        for (int c = 0; c < D_K; ++c) {
            float sum = 0.0f;
            for (int i = 0; i < SEQ_LEN; ++i) {
                sum += scores[r * SEQ_LEN + i] * v[i * D_K + c];
            }
            output[r * D_K + c] = sum;
        }
    }
}

void verify_results(const std::vector<float>& cpu_output, const std::vector<float>& gpu_output) {
    float max_error = 0.0f;
    for (size_t i = 0; i < cpu_output.size(); ++i) {
        max_error = std::max(max_error, fabsf(cpu_output[i] - gpu_output[i]));
    }
    std::cout << "Verification Max Error: " << max_error << std::endl;
    if (max_error > 1e-4) {
        std::cout << "VERIFICATION FAILED!" << std::endl;
    }
    else {
        std::cout << "Verification SUCCESS!" << std::endl;
    }
}