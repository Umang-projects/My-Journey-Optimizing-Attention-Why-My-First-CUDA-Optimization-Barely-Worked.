# -*- coding: utf-8 -*-
"""Naive Kernel.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/118tCIkRq8FjFQaanNsR7CwscG9g8AajR
"""

// ==================================================================================
// 1. Naive Kernels (Global Memory Only)
// ==================================================================================

// Kernel 1: Computes Scores = Q * K^T. Each thread computes one output element.
__global__ void matmul_naive_kernel(const float* q, const float* k, float* scores, int seq_len, int d_k) {
    int row = blockIdx.y * blockDim.y + threadIdx.y;
    int col = blockIdx.x * blockDim.x + threadIdx.x;

    if (row < seq_len && col < seq_len) {
        float sum = 0.0f;
        for (int i = 0; i < d_k; ++i) {
            // Accessing K in a transposed manner
            sum += q[row * d_k + i] * k[col * d_k + i];
        }
        scores[row * seq_len + col] = sum;
    }
}

// Kernel 2: Performs all subsequent steps: scaling, softmax, and matmul with V.
// Each thread handles one row of the final output.
__global__ void scale_softmax_gemm_kernel(float* scores, const float* v, float* output, int seq_len, int d_k) {
    int row = blockIdx.x * blockDim.x + threadIdx.x;

    if (row < seq_len) {
        // --- 1. Scale and find max for stable softmax ---
        float scale_factor = 1.0f / sqrtf((float)d_k); // Use fast reciprocal square root
        float max_val = -1e20f;
        for (int i = 0; i < seq_len; ++i) {
            scores[row * seq_len + i] *= scale_factor;
            max_val = fmaxf(max_val, scores[row * seq_len + i]);
        }

        // --- 2. Exponentiate and sum ---
        float exp_sum = 0.0f;
        for (int i = 0; i < seq_len; ++i) {
            float val = expf(scores[row * seq_len + i] - max_val);
            scores[row * seq_len + i] = val; // Overwrite scores with intermediate values
            exp_sum += val;
        }

        // --- 3. Normalize to get attention weights ---
        for (int i = 0; i < seq_len; ++i) {
            scores[row * seq_len + i] /= exp_sum;
        }

        // --- 4. Multiply by V ---
        for (int j = 0; j < d_k; ++j) { // For each element in the output vector
            float sum = 0.0f;
            for (int i = 0; i < seq_len; ++i) {
                sum += scores[row * seq_len + i] * v[i * d_k + j];
            }
            output[row * d_k + j] = sum;
        }
    }
}